## **Linux C编程一站式学习** ##

**2月14日**

机器语言都是数字，表示形式可以是二进制、十六进制等。

汇编器（Assembler）：查表，把汇编的助记符替换成数字，也就是汇编语言翻译成机器语言。

编译器（Compiler）：把一条C语句翻译成若干条汇编或机器指令。

C语言写出来的程序虽然需要花时间编译转为机器指令才能被计算机执行，但它是可移植的（Portable）或成为**平台**无关的（Platform Independent)。

平台：计算机体系结构（Architecture）、操作系统（Operating System）、开发平台（编译器、链接器）。

平台这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。

* 习题：1、解释执行的语言相比编译执行的语言有什么优缺点？

​	优点：不需要编译的过程，把每一行语句当作一条命令解释执行，相对实时地输出。

​	缺点：可移植性不强，不像C语言一样可跨平台运行，用C写的程序只需少量的甚至不需要改动便可在不同的计算机上编译运行，因为各种体系结构的计算机都有各自的C编译器。

C是一种形式语言，有严格的语法（Syntax）规则：符号（Token）规则和结构（Structure)规则

符号的规则：词法（Lexical）规则

结构的规则：语法（Grammer）规则

现在给出一些关于阅读程序（包括其它形式语言）的建议。首先请记住形式语言远比自然语言紧凑，所以要多花点时间来读。其次，结构很重要，从上到下从左到右读往往不是一个好办法，而应该学会在大脑里解析：**识别Token，分解结构**。最后，请记住细节的影响，诸如拼写错误和标点错误这些在自然语言中可以忽略的小毛病会把形式语言搞得面目全非。

也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。

Boilerplate

C程序总是从`main`里面的第一条语句开始执行

编译时加 -wall选项：

`gcc -Wall xxx.c`

`./xxx.c`

* 习题：1、尽管编译器的错误提示不够友好，但仍然是学习过程中一个很有用的工具。你可以像上面那样，从一个正确的程序开始每次改动一小点，然后编译看是什么结果，如果出错了，就尽量记住编译器给出的错误提示并把改动还原。因为错误是你改出来的，你已经知道错误原因是什么了，所以能很容易地把错误原因和错误提示信息对应起来记住，这样下次你在毫无防备的情况下撞到这个错误提示时就会很容易想到错误原因是什么了。这样反复练习，有了一定的经验积累之后面对编译器的错误提示就会从容得多了。

转义序列有两个作用：一是把普通字符转义成特殊字符，例如把字母n转义成换行符；二是把特殊字符转义成普通字符，例如\和"是特殊字符，转义后取它的字面值。

常量的的转换说明：

%c,%d,%f：*转义序列是编译时处理的，而转换说明是在运行时调用`printf`函数处理的*。

* 习题：1、总结前面介绍的转义序列的规律，想想在`printf`的格式化字符串中怎么表示一个%字符？写个小程序试验一下。

  `printf("%c",'%');`

C语言中的声明（Declaration）有变量声明、函数声明和类型声明三种。如果一个变量或函数的声明要求编译器为它分配存储空间，那么也可以称为定义（Definition），因此定义是声明的一种。在接下来几章的示例代码中变量声明都是要分配存储空间的，因而都是定义，等学到[第 2 节 “定义和声明”](https://akaedu.github.io/book/ch20s02.html#link.defdecl)我们会看到哪些变量声明不分配存储空间因而不是定义。在下一章我们会看到函数的定义和声明也是这样区分的，分配存储空间的函数声明可以称为函数定义。从[第 7 章 *结构体*](https://akaedu.github.io/book/ch07.html#struct)开始我们会看到类型声明，声明一个类型是不分配存储空间的，但似乎叫“类型定义”听起来也不错，所以在本书中“类型定义”和“类型声明”表示相同的含义。声明和语句类似，也是以;号结尾的，但是在语法上声明和语句是有区别的，语句只能出现在{}括号中，而声明既可以出现在{}中也可以出现在所有{}之外。

标识符(Identifier)：变量名、函数名、宏定义、结构体成员。以字母、下划线开头，只能包含数字、字母和下划线。

般来说应避免使用以下划线开头的标识符*，以下划线开头的标识符只要不和C语言关键字冲突的都是合法的，但是往往被编译器用作一些功能扩展，C标准库也定义了很多以下划线开头的标识符，所以除非你对编译器和C标准库特别清楚，一般应避免使用这种标识符，以免造成命名冲突。

*理解一个概念不是把定义背下来就行了，一定要理解它的外延和内涵，也就是什么情况属于这个概念，什么情况不属于这个概念，什么情况虽然属于这个概念但一般推荐的做法（Best Practice）是要尽量避免这种情况，这才算是真正理解了。*

定义一个变量，就是分配一块存储空间并给它命名；给一个变量赋值，就是把一个值保存到这块存储空间中。变量的定义和赋值也可以一步完成，这称为变量的初始化（Initialization），例如要达到上面代码的效果也可以这样写：

```
char firstletter = 'a';
int hour = 11, minute = 59;
```

*初始化是一种特殊的声明，而不是一种赋值语句*。

变量的最小存储单位是字节（Byte）。

目前我们学过的表达式中只有变量可以做左值，可以做左值的表达式还有几种，以后会讲到。

* 习题：1、假设变量`x`和`n`是两个正整数，我们知道`x/n`这个表达式的结果要取Floor，例如`x`是17，`n`是4，则结果是4。如果希望结果取Ceiling应该怎么写表达式呢？例如`x`是17，`n`是4，则结果是5；`x`是16，`n`是4，则结果是4。

  ⌈x/n⌉

**2月15日**

我们调用`printf`不是为了得到它的返回值，而是为了利用它所产生的副作用（Side Effect）－－打印。*C语言的函数可以有Side Effect，这一点是它和数学函数在概念上的根本区别*。

改变计算机存储单元里的数据或者做输入输出操作都算Side Effect。

在Linux平台上最广泛使用的C函数库是`glibc`，其中包括C标准库的实现，也包括本书第三部分介绍的所有系统函数。几乎所有C程序都要调用`glibc`的库函数，所以`glibc`是Linux平台C程序运行的基础。`glibc`提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在`libc.so`库文件中，几乎所有C程序的运行都依赖于`libc.so`，有些做数学计算的C程序依赖于`libm.so`，以后我们还会看到多线程的C程序依赖于`libpthread.so`。以后我说`libc`时专指`libc.so`这个库文件，而说`glibc`时指的是`glibc`提供的所有库文件。

`glibc`并不是Linux平台唯一的基础C函数库，也有人在开发别的C函数库，比如适用于嵌入式系统的`uClibc`。

操作系统在调用`main`函数时是传参数的，`main`函数最标准的形式应该是`int main(int argc, char *argv[])`，在[第 6 节 “指向指针的指针与指针数组”](https://akaedu.github.io/book/ch23s06.html#pointer.parray)详细介绍。C标准也允许`int main(void)`这种写法，如果不使用系统传进来的两个参数也可以写成这种形式。但除了这两种形式之外，定义`main`函数的其它写法都是错误的或不可移植的。

读代码的过程就是模仿计算机执行程序的过程，我们不仅要记住当前读到了哪一行代码，还要记住现在读的代码是被哪个函数调用的，这段代码返回后应该从上一个函数的什么地方接着往下读。

*形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化*。

* 习题：1、定义一个函数`increment`，它的作用是把传进来的参数加1。例如：

  ```
  void increment(int x)
  {
  	x = x + 1;
  }
  
  int main(void)
  {
  	int i = 1, j = 2;
  	increment(i); /* i now becomes 2 */
  	increment(j); /* j now becomes 3 */
  	return 0;
  }
  ```

  我们在`main`函数中调用`increment`增加变量`i`和`j`的值，这样能奏效吗？为什么？

  不能。形参是由实参的值初始化的，在自定义函数里的更改无法改变实参的值。

  2、如果在一个程序中调用了`printf`函数却不包含头文件，例如`int main(void) { printf("\n"); }`，编译时会报警告：`warning: incompatible implicit declaration of built-in function ‘printf’`。请分析错误原因。

​		头文件中包含对库函数的定义和声明，编译器有条规则是函数的隐式声明（Implicit Declaration），报警告。隐式声明的函数返回值类型都是`int`。

```
/*
* `main`函数中定义了局部变量`hour`，`print_time`函数中也有参数`hour`，虽然它们名称相同，但仍然是两个不同的变量，代表不同的存储单元。	
*/
void print_time(int hour, int minute)
{
	printf("%d:%d\n", hour, minute);
}

int main(void)
{
	int hour = 23, minute = 59;
	print_time(hour, minute);
	return 0;
}
```

​	正因为全局变量在任何函数中都可以访问，所以在程序运行过程中全局变量被读写的顺序从源代码中是看不出来的，源代码的书写顺序并不能反映函数的调用顺序。程序出现了Bug往往就是因为在某个不起眼的地方对全局变量的读写顺序不正确，如果代码规模很大，这种错误是很难找到的。而对局部变量的访问不仅局限在一个函数内部，而且局限在一次函数调用之中，从函数的源代码很容易看出访问的先后顺序是怎样的，所以比较容易找到Bug。因此，*虽然全局变量用起来很方便，但一定要慎用，能用函数传参代替的就不要用全局变量*。

表达式 → 函数名
 表达式 → 表达式(参数列表)
 参数列表 → 表达式, 表达式, ...

表达式 → 标识符
 表达式 → 常量
 表达式 → 字符串字面值
 表达式 → (表达式)
 表达式 → 表达式 + 表达式
 表达式 → 表达式 - 表达式
 表达式 → 表达式 * 表达式
 表达式 → 表达式 / 表达式
 表达式 → 表达式 = 表达式
 语句 → 表达式;
 语句 → printf(表达式, 表达式, 表达式, ...);
 变量声明 → 类型 标识符 = Initializer, 标识符 = Initializer, ...;
 （= Initializer的部分可以不写）

*局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化*。

如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。所以，*局部变量在使用之前一定要先赋值*。

```
#include <stdio.h>

void foo(void)
{
	int i;
	printf("%d\n", i);
	i = 777;
}

int main(void)
{
	foo();
	foo();
	return 0;
}	
```

```
int main(void)
{
	foo();
	printf("hello\n");
	foo();
	return 0;
}
```

关键的一点是，我说“初值不确定”，有没有说这个不确定值不能是0？有没有说这个不确定值不能是上次调用赋的值？在这里“不确定”的准确含义是：每次调用这个函数时局部变量的初值可能不一样，运行环境不同，函数的调用次序不同，都会影响到局部变量的初值。在运用逻辑推理时一定要注意，*不要把必要条件（Necessary Condition）当充分条件（Sufficient Condition）*，这一点在Debug时尤其重要，看到错误现象不要轻易断定原因是什么，一定要考虑再三，找出它的真正原因。例如，不要看到第二次调用打印777就下结论“函数中的局部变量具有一直存在的固定的存储空间，每次函数调用时使用它，返回时也不释放，再次调用函数时它应该还能保持上次的值”，这个结论倒是能推出777这个结果，但反过来由777这个结果却不能推出这样的结论。所以说777这个结果是该结论的必要条件，但不是充分条件。也不要看到第二次调用打印0就断定“局部变量未初始化则初值为0”，0这个结果是该结论的必要条件，但也不是充分条件。至于为什么会有这些现象，为什么这个不确定的值刚好是777，或者刚好是0，等学到[例 19.1 “研究函数的调用过程”](https://akaedu.github.io/book/ch19s01.html#asmc.func)就能解释这些现象了。

* 习题：1、以下程序段编译能通过，执行也不出错，但是执行结果不正确（根据[第 3 节 “程序的调试”](https://akaedu.github.io/book/ch01s03.html#intro.debug)的定义，这是一个语义错误），请分析一下哪里错了。还有，既然错了为什么编译能通过呢？

  ```
  int x = -1;
  if (x > 0);
  	printf("x is positive.\n");
  ```

* 习题：1、写两个表达式，分别取整型变量`x`的个位和十位。

  2、写一个函数，参数是整型变量`x`，功能是打印`x`的个位和十位。

  1. `gewei =  x % 10`

  `shiwei = (x / 10) % 10` 

  2. `myprintf(int x){printf("gewei:%d,%d",x % 10,(x / 10) % 10);} `

*尽可能复用（Reuse）以前写的代码，避免写重复的代码*

![函数的分层设计](https://akaedu.github.io/book/images/func2.stratify.png)



**2月17日：**

Q：gdb单步调试时形参第一次输出老显示为0(c_test.c)

A：15.1 Implementation-defined？对于Unspecified的情况，往往有几种可选的处理方式，C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式，比如下一章我们会讲到一个函数调用的各个实参表达式按什么顺序求值是Unspecified的。

Q:gdb里list显示不全，前几行缺失

A:

Q:reverse_str是olleh，输出是ollehhello

A：

Q：test.c输入为12345时没像教程似的出现问题

* 每个字符串结尾都固定有一个结束符（‘\0’），故应将str串的前五位转置放入reverse_str的前五位

 `reverse_str[5 - i] = str[i]`改为`reverse_str[4 - i] =  str[i]`

* 题目原因还有就是前面改成了`char reverse_str[5] = "";`，不知为何是这个输出

Q：10.3观察点未完成

A：

Q：

“断点加单步”是使用调试器的基本方法

段错误实例：

```
#include<stdio.h>

int main(void)
{
	int man = 0;
	scanf("%d",man);   // 应为：scanf("%d",&man);
	return 0;
}
```

**2月18日**

C语言与平台和编译器是密不可分的，离开了具体的平台和编译器讨论C语言，就只能讨论到本书第一部分的程度了。





















